 //#define PROGMEM ICACHE_RODATA_ATTR 
#include <ESP8266WiFi.h>
#include <WiFiClient.h>
#include <EEPROM.h>
#include <Arduino.h>
#include <ArduinoJson.h>
#include <EasyDDNS.h>

//https://arduinojson.org/v6/assistant/


// Configurar WiFi generada
const char* ssid     = "Ronald-L337";
const char* password = "fmlaforero1234";

const short int LED = 2; //GPIO2
char rele1, rele2, rele3, rele4, rele5, rele6;
int cont, banConnect,str_len;
int eeAddress = 0;
bool suiche2,suiche3,suiche4; //varibles suiches seran guardadas en la EEPROM
String suiche1;
bool ban,bandera;
String datos, datas;

//Lectura del lector de corriente
float Sensibilidad=0.066; //sensibilidad en Voltios/Amperio para sensor de 30A
String corriente1, corrienteA;

// valor guardado en la ram
volatile float imax_client=100000000000.0;
float im_rec;


//float SENSIBILITY = 0.185; // Modelo 30A
//const int AnalogIn = A0;
//int SAMPLESNUMBER = 100;



// ################################################################## PROTOCOLO TCP

WiFiServer servidorTCP(8266); //puerto 8266, CANTV bloquea del 0 al 1024
WiFiClient clienteTCP;


void setup() {

//Inicializamos la comunicacion por puerto SERIAL
  Serial.begin(115200);
  EEPROM.begin(100); //size 100 bytes. el rango es de 4 a 4096
  delay(100);

datos.reserve(100);  
ban=false;  
banConnect=0; // falso=0
cont=0;
bandera= false;

// ################################################################## CONFIGURACION DEL DDNS CON NO IP

EasyDDNS.service("noip");    // Enter your DDNS Service Name - "duckdns" / "noip"
EasyDDNS.client("tesis.ddns.net","l337_ronal","ronald321");    // Enter ddns Domain & Username & Password | Example - "esp.duckdns.org","username", "password"


//  
//suiche1="true";
//int tamano = suiche1.length();
//char inchar[tamano];
////convertimos la variable suiche en char array
//suiche1.toCharArray(inchar, tamano+1);
//
////con length sabemos el tamaño de la variable
//    for(int i=0; i<tamano;i++){
//       EEPROM.write(eeAddress+i, inchar[i]);
//    }
//    EEPROM.end();
////

//
//EEPROM.end();

//suiche1=HIGH;
//  EEPROM.put( eeAddress, suiche1 );  //Grabamos el valor
//  eeAddress += sizeof(float);  //Obtener la siguiente posicion para escribir
//  if(eeAddress >= EEPROM.length()) eeAddress = 0;  //Comprobar que no hay desbordamiento
//  EEPROM.commit();
//  delay(30000); //espera 30 segunos
//




//sensor de corriente
  //pinMode(AnalogIn, INPUT);
  pinMode(LED, OUTPUT);
  
// SHIELD RELE con un bajo se activan
  pinMode(16, OUTPUT);

//LED aagado (para apagarlo hay que estar en alto)
  digitalWrite(LED,HIGH);

ESP.getFreeHeap () ;
WiFi.begin(ssid, password);//Intentamos conectarnos a la red Wifi  

// Esperar a que nos conectemos
  
  while (WiFi.status() != WL_CONNECTED) {  //Esperamos hasta que se conecte.

// Intentando Conectar a la RED
    //Prendemos y apagamos el LED (parpadeo del led)
    digitalWrite(LED,LOW);
    delay(100);
    digitalWrite(LED,HIGH);
    delay(50);
    digitalWrite(LED,LOW);
    delay(100);
    digitalWrite(LED,HIGH);
    delay(50);
    digitalWrite(LED,LOW);
    delay(100);
    digitalWrite(LED,HIGH);
    
  } // FIN  while (WiFi.status() != WL_CONNECTED)
  
      //prendemos el led del nodemcu, quiere decir que si hizo conexion
      digitalWrite(LED,LOW);
      // dejamos el LED prendido un momento indicando que fue conectado a la RED
        delay(4000);
      Serial.print ("Conectado, IP: ");
      Serial.println (WiFi.localIP());
      
      // Imprimimos las MAC ADDRESS
      Serial.print("MAC: ");
      Serial.println(WiFi.macAddress());
    
      //Imprimimos el hostname
      Serial.printf("Hostname por defecto: %s\n", WiFi.hostname().c_str());
      // nos conectamos con el protocolo TCP
      servidorTCP.begin();

}







void loop() {



// Si el cliente TCP no esta conectado
  if (!clienteTCP.connected()) {
        // try to connect to a new client


  //Serial.print("ESPERANDO CONECTAR NUEVO CLIENTE");


  //Aqui esta esperando a que un cliente se conecte
  // Mientras no haya cliente disponible, prendemos y apagamos el led

   //Prendemos y apagamos el LED (parpadeo del led)
    digitalWrite(LED,LOW);
    delay(100);
    digitalWrite(LED,HIGH);
    delay(50);
    digitalWrite(LED,LOW);
    delay(100);
    digitalWrite(LED,HIGH);
    delay(50);
    digitalWrite(LED,LOW);
    delay(100);
    digitalWrite(LED,HIGH);
 
          clienteTCP = servidorTCP.available();
    
    } // FIN (!clienteTCP.connected()) {
    
    
    else    
    {  // Cliente TCP conectado

      // Apagamos el LED, esto quiere decier que se conecto a un cliente
          digitalWrite(LED,HIGH);

        // leyendo data del cliente conectado
        if (clienteTCP.available() > 0) 
        {

// Prendemos el LED, quiere decir que esta recibiendo data
    digitalWrite(LED,LOW);


//Leemos el valor del sensor de corriente
//  float Sensibilidad=0.066; //sensibilidad en Voltios/Amperio para sensor de 5A
//  float voltajeSensor= analogRead(A0)*(5.0 / 1023.0); //lectura del sensor   
//  float I=(voltajeSensor-2.5)/Sensibilidad; //Ecuación  para obtener la corriente
//  corriente1= String(I);


//float current = getCorriente(SAMPLESNUMBER);
//  float currentRMS = 0.707 * current;
//  float power = 230.0 * currentRMS;
//
//  printMeasure("Intensidad: ", current, "A ,");
//  printMeasure("Irms: ", currentRMS, "A ,");
//  printMeasure("Potencia: ", power, "W");
//  delay(1000);
//  corriente1= String(current);
//  Serial.println("valor de corriente");
//  Serial.print(corriente1);



EasyDDNS.update(90000); // Check for New Ip Every 90 Seconds.


// LEEMOS LA CORRIENTE CONSTANTEMENTE
   float voltajeSensor= analogRead(A0)*(3.3 / 1023.0); //lectura del sensor   
   float I=(voltajeSensor-2.27)/Sensibilidad; //Ecuación  para obtener la corriente
   
   if (I>=imax_client){
     corrienteA=String(I);
    const size_t capacity = JSON_OBJECT_SIZE(1);
    DynamicJsonDocument doc(capacity);
    doc["i_alerta"] = corrienteA;  
    serializeJson(doc, Serial);

    char json_string[100];
    serializeJson(doc, json_string);
    Serial.println(json_string);
    //enviamos el JSON a la APP
    clienteTCP.write(json_string);
    //limpiamos la variable datos
    datos="";
   }



// LEYENDO DATOS DE LLEGADA    
//String dato = clienteTCP.read();
char  dato = clienteTCP.read();
//String dato = clienteTCP.readStringUntil('\r');
//Serial.println(dato);



//PING DESCONECTAR
if (dato=='D'){
 
  clienteTCP.flush();
  clienteTCP.stop(); // paramos conexion
Serial.print("Socket Cerrado");  
//limpiamos la variable datos
datos="";
  }



//PING ACTUALIZAR
if (dato == 'B' ){


// RUTINA SENSOR DE CORRIENTE
 
  float voltajeSensor= analogRead(A0)*(3.3 / 1023.0); //lectura del sensor   
  float I=(voltajeSensor-2.27)/Sensibilidad; //Ecuación  para obtener la corriente
  corriente1= String(I); //esta variable la enviamos por socket
  Serial.print("Corriente: ");
  Serial.println(I,3); 
  delay(100);    

  
const size_t capacity = JSON_OBJECT_SIZE(2);
DynamicJsonDocument doc(capacity);

//Se envian las corrientes.. los siches casi no importa, se envia el estado en la eeprom
doc["l1"] = suiche1;
doc["c1"] = corriente1;
char json_string[100];
serializeJson(doc, json_string);
Serial.println(json_string);
//enviamos el JSON a la APP
clienteTCP.write(json_string);
//limpiamos la variable datos
datos="";
} //FIN ACTUALIZAR



// PING CONECTAR
if (dato == 'A'){
Serial.print("entro a conectar");  
  // si llega da "A" enviamos un ok o recibido enviando un "A"
  //recibimos un "A" y devolvemos un "A"
   clienteTCP.write("A");

     
    const size_t capacity = JSON_OBJECT_SIZE(1);
    DynamicJsonDocument doc(capacity);

    //Leemos de la EEPROM y luego igualamos
    EEPROM.get( eeAddress, suiche1);
    doc["l1"] = suiche1;
    Serial.println(suiche1);

    
    char json_corrientes[100];
    serializeJson(doc, json_corrientes);   
    //enviamos el JSON a la APP
    clienteTCP.write(json_corrientes); 
    Serial.print(json_corrientes);

//limpiamos la variable datos
datos="";
Serial.print("envio JSON");  
   
}// FIN PING CONECTAR





// RECIBIENDO LOS JSON


// ################################################################## GUARDAR CORRIENTE          
//la corriente que viene del cliente, variable lm1

DynamicJsonDocument doc(1024);
deserializeJson(doc, datos);

bool hasLm1 = doc.containsKey("lm1"); // true or false
if (hasLm1) {

Serial.print("SI SE ENCUENTRA"); 
//concatenamos cada caracter que llega en un string
datos += dato;


    //el tamaño de la variable
    str_len = datos.length();  
    Serial.print("tamaño del dato"); 
    Serial.println(str_len);
    //creamos una variable char array con ese tamaño
    char char_array[str_len];
    //convertimos el char en array char      
    datos.toCharArray(char_array, str_len);   


    // Deserilizando el JSON
    const size_t capacity = JSON_OBJECT_SIZE(1) + 10;
    DynamicJsonDocument doc(capacity);
    deserializeJson(doc, datos);
    // s1 viene como string
    String im_rec= doc["lm1"]; //nuevo dato
    Serial.print('\n');
    Serial.println("valor de  CORRIENTE");
    Serial.print(im_rec);
    
//guardamos la corriente en una variable volatile, es decir en la ram
imax_client = im_rec.toFloat();

}


// ################################################################## SUICHE
// valor booleano, variable l1

bool hasL1 = doc.containsKey("l1"); // true or false
if (hasL1){


//concatenamos cada caracter que llega en un string
datos += dato;


    //el tamaño de la variable
    str_len = datos.length();  
    Serial.print("tamaño del dato"); 
    Serial.println(str_len);
    //creamos una variable char array con ese tamaño
    char char_array[str_len];
    //convertimos el char en array char      
    datos.toCharArray(char_array, str_len);   


      if (str_len==12 || str_len==13){ 
         // dato 13 es false y dato 12 es true
         Serial.print("datos");
         Serial.println(datos);


            // Deserilizando el JSON
            const size_t capacity = JSON_OBJECT_SIZE(1) + 10;
            DynamicJsonDocument doc(capacity);
            deserializeJson(doc, datos);
            // s1 viene como string
            String s1= doc["l1"]; //nuevo dato
            Serial.print('\n');
            Serial.println("valor de  S1");
            Serial.print(s1);


            // Actualizamos el estado de los suiches en la EEPROM

            //leemos suiche1
            EEPROM.get( eeAddress, suiche1);
            Serial.print("Valor de suiche 1:");
            Serial.println(suiche1);
            delay(3000); //esperamos a que lea

            bool rele;

            if (s1=="true")rele=HIGH;
            else rele=LOW;

            if (s1 != suiche1){  
               //Actualizamos el vaor en la EEPROM
               //Si el valor es el mismo no lo guarda.
               
//               Serial.print("valor de suiche cambio a:");
//               Serial.println(suiche1);
//
//               EEPROM.put(eeAddress, suiche1);
//               EEPROM.commit();  
//               eeAddress += sizeof(int);
//               if(eeAddress == EEPROM.length()) eeAddress = 0;
//               delay(4000);  //Espera de 4 segundos
               
                Serial.print(" DESCOMENTAR LINEAS valor de suiche grabo en la eeprom:");
                Serial.println(suiche1);
               
               digitalWrite(16, rele); 

               
            } // FIN if (s1 != suiche1)

//suiche1=HIGH;
//  EEPROM.put( eeAddress, suiche1 );  //Grabamos el valor
//  eeAddress += sizeof(float);  //Obtener la siguiente posicion para escribir
//  if(eeAddress >= EEPROM.length()) eeAddress = 0;  //Comprobar que no hay desbordamiento
//  EEPROM.commit();
//  delay(30000); //espera 30 segunos



////if (s1 != suiche1){ //nunca va pasar que sean iguales
////  
    //Actualizamos el vaor en la EEPROM
    //Si el valor es el mismo no lo guarda.
     suiche1=s1;
Serial.print("valor de suiche cambio a:");
Serial.println(suiche1);
////
////     
////     EEPROM.put(eeAddress, suiche1);
////     EEPROM.commit();  
////     eeAddress += sizeof(int);
////     if(eeAddress == EEPROM.length()) eeAddress = 0;
////     delay(4000);  //Espera de 4 segundos
////Serial.print("valor de suiche grabo en la eeprom:");
////Serial.println(suiche1);
////     
////     digitalWrite(16, suiche1);  

        
         Serial.print("limpiamos datos");
         //Limpiamos 
         str_len=0;
         //limpiamos  la concatenacion
         datos="";
      }

}// FIN SUICHE




      
} // FIN DE HAY CONEXION       
}// caso contrario NO hay conexion
} //FIN VOID LOOP
